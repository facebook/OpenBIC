/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef PLAT_STATUS_H
#define PLAT_STATUS_H

#include <stdint.h>
#include "plat_util.h"
#include "plat_threshold.h"

enum AALC_MODBUS_SENSOR_STATUS_E {
	RPU_FAN_STATUS, // 0x900E
	RPU_PUMP1_STATUS, // 0x9012
	RPU_PUMP2_STATUS, // 0x9013
	RPU_PUMP3_STATUS, // 0x9014
	RPU_RESERVOIR_STATUS, // 0x9016
	ALL_PUMP_STATUS, // 0x9018
	ALL_RPU_INTERNAL_FAN_STATUS, // 0x9019
	PUMP_FAN_STATUS, // 0xA080
	HEX_BLADDER_LEVEL_STATUS, // 0x9113
	AALC_SENSOR_ALARM, // 0x9200
	HEX_AIR_THERMOMETER_STATUS, // 0xA202
	AALC_STATUS_ALARM, // 0x9201
	HEX_FAN_ALARM_1, // 0x9203
	HEX_FAN_ALARM_2, // 0xA201
	HEX_FAN_COMMS_ALARM, // 0xA205
	HSC_POWER_STATUS, // 0xA203
	FB_HSC_POWER_STATUS, // 0xA204
	HSC_COMMS_STATUS, // 0xA206
	FB_HSC_COMMS_STATUS, // 0xA207
};

enum AALC_STICKY_STATUS_E {
	STICKY_ITRACK_CHASSIS0_LEAKAGE, // 0x19A1
	STICKY_ITRACK_CHASSIS1_LEAKAGE, // 0x19A2
	STICKY_ITRACK_CHASSIS2_LEAKAGE, // 0x19A3
	STICKY_ITRACK_CHASSIS3_LEAKAGE, // 0x19A4
	STICKY_RPU_INTERNAL_LEAKAGE_ABNORMAL, // 0x19A5
	STICKY_RPU_EXTERNAL_LEAKAGE_ABNORMAL, // 0x19A6
	STICKY_RPU_OPT_EXTERNAL_LEAKAGE1_ABNORMAL, // 0x19A7
	STICKY_RPU_OPT_EXTERNAL_LEAKAGE2_ABNORMAL, // 0x19A8
	STICKY_HEX_RACK_PAN_LEAKAGE, // 0x19A9
	STICKY_HEX_RACK_FLOOR_LEAKAGE, // 0x19AA
	STICKY_HEX_RACK_PAN_LEAKAGE_RELAY, // 0x19AB
	STICKY_HEX_RACK_FLOOR_LEAKAGE_RELAY, // 0x19AC
	STICKY_STATUS_MAX,
};

enum PUMP_STATUS_E {
	PUMP_STATUS_DISABLE = 0,
	PUMP_STATUS_REDAUNDANT = 1,
	PUMP_STATUS_ENABLE = 2,
	PUMP_STATUS_MAINTAIN = 3,
	PUMP_STATUS_ABNORMAL = 4,
};

enum AALC_STATUS_LEAK_E {
	AALC_STATUS_IT_LEAK_0 = 0,
	AALC_STATUS_IT_LEAK_1 = 1,
	AALC_STATUS_IT_LEAK_2 = 2,
	AALC_STATUS_IT_LEAK_3 = 3,
	AALC_STATUS_CDU_LEAKAGE = 4,
	AALC_STATUS_RACK_LEAKAGE = 5,
	AALC_STATUS_LEAK_E_MAX,
};

enum STATUS_FLAG_E {
	STATUS_FLAG_LEAK,
	STATUS_FLAG_FAILURE,
	STATUS_FLAG_AUTO_TUNE,
	STATUS_FLAG_PUMP_REDUNDANT,
	STATUS_FLAG_SYSTEM_READY,
	STATUS_FLAG_SETPOINT_FLAG,
	STATUS_FLAG_SPECIAL_MODE,
	STATUS_FLAG_HSC_FAIL,
	STATUS_FLAG_MAX,
};

enum PUMP_REDUNDANT_STATUS_E {
	PUMP_REDUNDANT_DISABLE,
	PUMP_REDUNDANT_12,
	PUMP_REDUNDANT_13,
	PUMP_REDUNDANT_23,
	PUMP_REDUNDANT_MAX,
};

enum FAILURE_STATUS_E {
	// 0
	PUMP_FAIL_EMERGENCY_BUTTON,
	PUMP_FAIL_LEAK,
	PUMP_FAIL_ABNORMAL_PRESS,
	PUMP_FAIL_ABNORMAL_FLOW_RATE,
	PUMP_FAIL_LOW_LEVEL,
	PUMP_FAIL_LOW_RPU_LEVEL,
	PUMP_FAIL_PUMP1_UCR,
	PUMP_FAIL_PUMP2_UCR,
	PUMP_FAIL_PUMP3_UCR,
	PUMP_FAIL_TWO_PUMP_X,
	PUMP_FAIL_CLOSE_PUMP,
	// 100
	PUMP_FAIL_TWO_HEX_FAN_FAILURE,
	PUMP_FAIL_ABNORMAL_COOLANT_INLET_TEMP,
	PUMP_FAIL_ABNORMAL_COOLANT_OUTLET_TEMP,
	PUMP_FAIL_ABNORMAL_AIR_INLET_TEMP,
	PUMP_FAIL_FLOW_RATE_NOT_ACCESS, // only pump
	HEX_FAN_FAIL_COOLANT_OUTLET_TEMP_NOT_ACCESS, // only hex fan
	// gpio
	GPIO_FAIL_BPB_HSC,
	FAILURE_STATUS_MAX,
};

enum SETPOINT_FLAG_STATUS_E {
	SETPOINT_FLAG_LPM,
	SETPOINT_FLAG_OUTLET_TEMP,
	SETPOINT_FLAG_MAX,
};

enum SPECIAL_MODE_STATUS_E {
	SPECIAL_MODE_PUMP_THRESHOLD_DEBUG,
	SPECIAL_MODE_2ND_BOOT_UPDATE,
	SPECIAL_MODE_MAX,
};

enum HSC_FAIL_STATUS_E {
	HSC_FAIL_BPB,
	HSC_FAIL_PUMP_1,
	HSC_FAIL_PUMP_2,
	HSC_FAIL_PUMP_3,
	HSC_FAIL_FB_1,
	HSC_FAIL_FB_2,
	HSC_FAIL_FB_3,
	HSC_FAIL_FB_4,
	HSC_FAIL_FB_5,
	HSC_FAIL_FB_6,
	HSC_FAIL_FB_7,
	HSC_FAIL_FB_8,
	HSC_FAIL_FB_9,
	HSC_FAIL_FB_10,
	HSC_FAIL_FB_11,
	HSC_FAIL_FB_12,
	HSC_FAIL_FB_13,
	HSC_FAIL_FB_14,
};

uint32_t get_status_flag(uint8_t idx);
void set_status_flag(uint8_t idx, uint8_t bit, uint32_t val);
uint16_t get_sticky_sensor_status(uint8_t idx);
bool set_sticky_sensor_status(uint8_t idx, uint16_t val);
uint16_t get_sensor_status_for_modbus_cmd(uint8_t status);

#endif //PLAT_STATUS_H
